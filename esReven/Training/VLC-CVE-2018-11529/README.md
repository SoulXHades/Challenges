# Guided Exercise: Analysis of CVE-2018-11529 (an RCE in VLC) with esReven

<img src='./images/eshard.png' style='width: 180px; float:right;'>

---

* **Guided Exercise: Analysis of CVE-2018-11529 (an RCE in VLC) with esReven**
* Classification: __RESTRICTED__
* _CATEGORY_: Tutorial

---

<img src='./images/header.png' style='height: 200px; display: block; margin-left: auto; margin-right: auto;'>


## 1. Introduction

CVE-2018-11529 is a vulnerability enabling Remote Code Execution in VLC media player via specially crafted MKV files. This exercise is based on a record of a proof of concept of that vulnerability. Its goal is to present the various features of esReven and how they can be used in the context of a simple vulnerability analysis, and more importantly to serve as a gentle introduction to the mindset of working with timeless analysis.

In this exercise, we will take some time to browse the trace randomly, then we will discover what happened during the record and the effect of the proof of concept. Starting from there, we will use various features to jump to moments where key things happen.

You can see this notebook's plan by clicking on the "Table Of Content" icon to the left of JupyterLab's file tree.

This notebook will make use of a scenario that is provided alongside this module.

Please run the following cell to automatically make sure the scenario is imported and get a working trace. If it isn't already, it will take about 20 minutes.

<div class="alert alert-block alert-info">
<b>Note:</b> if you already have this scenario, the cell will simply not import it.
</div>


```
from IPython.display import HTML, display

import reven2  # noqa: F401
import reven2.preview.taint
import reven2.preview.windows as windows
from reven2.address import LinearAddress, LogicalAddress, LogicalAddressSegmentIndex, PhysicalAddress  # noqa: F401
from reven2.arch import x64 as regs  # noqa: F401
from reven2.preview.project_manager import ProjectManager
from reven2.preview.taint import Tainter
from reven2.types import * # For values like U64

import sys
sys.path.append("../")
import utils

pm = ProjectManager("http://reven:8880/")
utils.import_scenario(pm, "./scenario/vlc-exploit_ac6915e4-1995-4227-998c-62f59ad51120.zip")
```


## 2. Discovering the GUI
You should have the GUI open by now. If not, the scenario is named vlc-exploit. Locate it in the project manager's scenario list and click on the "Analyze" button to the right. Finally, on the page that just opened, click on "Start Axion".

Make sure the following widgets are visible: framebuffer, CPU registers, backtrace and search / timeline. If not, you can open them through the Windows menu. Don't hesitate to resize and/or move them as needed.

We suggest you take some time to play around the trace, randomly browse it to get a feeling of basic navigation. There is a lot of information contained in a single trace so this step will probably not help you understand the bigger picture. Hence, at this point it's ok to be lost in the trace, because we are not looking for anything specific.

This first step is really optional, but here is a list of things you could try:

-   Scroll around, click randomly in the timeline, look at the backtrace and the framebuffer.
-   Jump at transition #12300000 and take a close look at the framebuffer: what do you see happening? Does this match what the backtrace tells you?

    -   Jump to the beginning of the call to `CopyBits32_32` using the backtrace or "Step Out Backward", then to its end using the "Step Over"" while the call instruction is selected. Look at the framebuffer each time.

-   At any moment, double-click on an instruction operand referencing memory: click on the link that appears to open an hexdump view at that address
-   At any moment, right click on rsp (or any register that contains an address) in the CPU widget and click on "Follow as address using default segment: you now see the content of that address. Then, move away from that moment of the trace using the timeline widget: you may land in a moment where the machine executes a completely different process and that address is not mapped anymore. In that case, "?" will be displayed instead of valid data.

There are shortcuts for most action and widgets. See the list in the "Actions" -> "Edit shortcuts" or by pressing F11. Some shortcuts may be intercepted by your window manager or your browser when using the esReven GUI through VNC.

Once you think you've played enough with the trace, move on to the next part.



## 3. Discovering the trace

If you have not seen it yet, here is a quick way to discover what has been recorded in the trace:

Using the timeline or the "Jump to" field, jump at approximately the following locations and look at the framebuffer:

-   #0: see the state of the VM at the start of the recording. Note that when creating that record, we tried to keep everything that was unnecessary out of the record: booting the VM, opening VLC, etc.
-   ~#100000000: "Open file" dialog is closed, and VLC is reading the file
-   ~#4000000000: still reading... most of the trace is VLC working on the 1-Gb-large proof-of-concept file.
-   ~#4200000000: VLC has disappeared from screen,
-   ~#4600000000: a message popup appears.


## 4. Jumping to the malicious binary

Our first step here will be finding the execution of that message box. For that, an easy entry point will be using the strings widget: it presents a view of memory regions that were read or written to during the trace and that look like strings. Note, it is not a view of all static strings from loaded binaries, although some of those may appear in the widget if they are read somewhere in the trace.

Looking at the framebuffer at the end of the trace reveals the message `We've got you`. Since this is drawn during the trace, we know that a string has been read from memory, copied to maybe several buffers and passed through various calls.

Open up the strings widget and filter on the string we've got you (it is case insensitive). There are a few results, which are sorted by first access time.

Double click on the first result (address 0x404038). All the accesses that occurred to this specific instance of the string appear at the bottom of the widget. Are they reads or writes?

Double click on the second string (address 0x103ac0), and look at the accesses: now the first access is a write.

It looks like the first string was read, and probably copied onto the second one. Maybe the first one is the static string from a binary? This is easy to check: open the address 0x404038 in a hexdump view (use the Ctrl+G shortcut). If you get only "?" instead of valid memory, it is because this address is not mapped at the moment that is currently selected in the trace. Double clicking on an access of this string will get you to a moment where it is. Scroll up to 0x400000 (you can also open this address directly): does that confirm this string is the static string from the binary?

Now let's look at where this first string is accessed. Double click on the first access (at the top of the list) of that first string, and look at the backtrace: what seems to be the main binary currently running? Does the address space of this binary match the string's address?

Could we simply scroll up to see who started that binary? In the backtrace, double-click on the call BaseThreadInitThunk, and try to scroll up a bit; don't waste too much time, though: the starting of a binary is a long process, and finding the CreateProcess would take too long.


## 5. Jumping to the shellcode

We would like to see where this binary is executed, but could not find it easily by browsing. There are multiple functions that could be used to spawn a process from user-land, but ultimately they all end up calling `CreateProcessInternalW`.

Let's see if it is called in the trace: In the search widget, select "Symbol Call" if not selected, type the binary kernelbase and select the full binary path, and finally type `CreateProcessInternalW`. Press enter (or click on Search).

There is a result! Select it in the combo box, or click "Next" on the right of that combo box, or press F4. This will get you to that moment of the trace.

Look at the backtrace. You see this is called ultimately by `WinExec`, which is seldom used nowadays. Moreover, the backtrace stops there, you don't know what called `WinExec`. These two elements are suspicious, so double-click on `WinExec`.

Scrolling up a bit, you see an "unknown" symbol. Code can be marked as such when esReven cannot find a corresponding binary on disk: this happens with JIT'ed code, or obviously with shellcodes which are manually loaded & executed.

You also see there are strings being accessed. What do you think those strings are? Does it give you an idea of what the code is trying to do?

Verify the arguments to `WinExec`; this is probably obvious, but remember that in x64 the usual calling convention is placing arguments in rcx, rdx, r8, r9, then on the stack. Here is the prototype to that function:

```c
UINT WinExec (LPCSTR lpCmdLine, UINT uCmdShow);
```

Is this the call we're looking for?

We would like to see where the first argument has been written in memory: by now you should have opened the address contained in rcx at the moment of the `WinExec` call in an hexdump widget. At the bottom of that widget, click on "Show access history". This displays the entire list of accesses on that address.

By default, showing this history preselects the preceding access. In this case it is a write, double-click on it. Do you see how the shellcode writes this argument?

From there, scroll up a bit, what function are we returning from? Does it make sense?

Place a bookmark at the start of the shellcode (Ctrl+D) so we can return here later on.


## 6. Origin of the shellcode

### First approach

Before we find out how this shellcode was called, let's take a moment to manually track where it comes from.

To do so, open any byte that is executed in memory:
1. In the "View" menu, click on "Open Address" (Ctrl+G).
2. Enter the for example the address `0x40000540`, and press Enter.
3. In the memory view, check "Show access history of selection" to open up the memory history.

One access is already selected. Remember that this view automatically selects the closest access prior (or at) the currently selected transition - in our case, it selected the previous write.

<div class="alert alert-block alert-info">
<b>Note:</b> the history does not show the "Execute" type of accesses, so in this case the execute after write is not obvious.
</div>

Double-click on this write access: you moved back in time.

We land in a memcpy call. That in itself is not very interesting, so take a look at the backtrace: what does it look like?

The shellcode was apparently read from the VLC's stream.

### Going deeper.

OK that's nice, but we can't always rely on having the target program's symbols. Let's see if we can get a better answer.

Similarily as before, we will move one step up the chain of copies, and try to get to that source buffer's origin.

Try and make out the source buffer's address so we can open it up in the memory view. There are multiple approaches:
- Read the assembly, identify where `xmm0` is written to, double-click on the memory operand there & open it up
- Get back to the start of the call to `memcpy` and identify the source buffer's start.

Let's say we chose the first method, to stay close to our shellcode specifically.
1. Open up address `0x8cb6365`.
2. Identify the closest previous write access and double-click on it.

Again, we land in a `memcpy`: that's a common pattern there. However, this time we are in kernel land. Look all the way to the end of the backtrace: you will see we are in a call to `NtReadFile`.

This is a much more generic clue, as it only relies on system symbols. Double-click on the call to `NtReadFile`.

```c
NTSTATUS NtReadFile (HANDLE FileHandle, ...)
```

Using the above prototype you should be able to retrieve the handle to the file.

But which file exactly are we reading? From there, getting to know that would require parsing the kernel structures about file handles. Luckily, esReven's API can parse a few of the Windows kernel objects, and handles are one of them.

In the following cells, please fill the gaps in order to read the handle. We recommend you search the <b class="jp-MEI-link"><i>/applications/reven/reven-documentation?link=api-cookbook/index.html</i>Cookbook</b> for how to get the handle from a context (use the cookbook's search button!).

```
# Let's connect first.
server = pm.get_server_by(name="vlc-exploit")
trace = server.trace
```

You should see the source `poc.mkv` file.

The alternative approach would have been to connect `WinDbg` to that trace, and simply ask it to resolve the handle as well. The advantage of that solution is of course that it works for every object that esReven does not support natively. We will see how to do that later.


## 7. Finding the exploit

Now that's we have validated the shellcode's origin, let's track back a bit.

Using the bookmark widget (Alt+Shift+B), go back to the start of our shellcode. Alternatively, you can use the "Go back" function (left arrow in the toolbar or Alt+Left) multiple times; this latter option will probably come in handy many times during your analyses!

We'd like to go to the start of this shellcode. Scroll up a bit: we are inside a loop. There is no easy generic shortcut to get out of a loop. Instead, we can search for all executions of the first address of this loop, and go to the first. This is a trick that usually gets us by.
1. In the search widget, change the upper-left combo-box from "Symbol Call" to "Address"
2. Enter the start address of the loop, that is `0x40000579`, and click on "Search"
3. All results are condensed in a very narrow location. We want to go to the first one:
    1. Using the timeline, navigate at any transition prior to these results
    2. Click on "Next": you are on the first result.
4. Scroll up a bit: we soon reach the start of the shellcode.

At this time, we're returning from a call to `VirtualProtect`. Try to go back to the start of that call using the usual "Step out backward": it does **not** work. The reason is that the exploit did not legitimately call the function `VirtualProtect`, but instead did shenanigans with our stack before to set this chain up.

Instead, we can select the `ret` of the call to `NtProtectVirtualMemory` and "Step Out Backward" from there.

Scrolling up again, we finally find code from vlc.exe. What do these instructions look like to you?

The exploit is setting things up.


## 8. Finding the vulnerability

Finally, we want to understand which vulnerability is being leveraged here. Notice how the stack pivot at transition #3991144274 follows what looks like a legit indirect call `call qword ptr [r10 + 0x10]` from a vlc DLL. What address is being dereferenced here?

This address is in the range of 0x40000000, which is the same range the shellcode lives in. Plus, while most of the addresses look normal, this one looks hardcoded (because it is very aligned), so it is probably safe to assume that it is controlled by the attacker.

Notice how r10 (`0x400003e8`) comes itself from a series of dereferencings right above. Look up the trace at each instruction that makes a dereferencing and try to find the first time the value it is accessing a memory location which belongs to a different range than 0x40000000.

At this point you should be looking at transition #3991144269. Which register is the address stored in? `rsi`! This is interesting because `rsi` is often used to store the `this` pointer in c++ calls. You can verify it's the case here by selecting `rsi` with your mouse in the trace to highlight it. Scroll up a bit: it's coming from rcx, the first argument of a c++ member function: `rsi` is indeed our this pointer.

What can you conclude about the state of our object?

We're looking at a call to an object's nested pointer chain, which ends up in a strange place, so it seems safe to assume that our object is corrupted.

Place a bookmark on the suspected vulnerability, and include the pointer value in the description for reference.

One way an object can be corrupted is if it is used after free. This possibility is easy to check here: we can look for a call to the destructor to that type applied on our object before that moment in the trace.

In the search widget, make sure "Symbol call" is selected. Can you infer what binary and symbol we should be looking for, based on the C++ namespace?

Look for `libmkv_plugin!matroska_segment_c::~matroska_segment_c`
-   Do we have results before the suspected UAF?
-   Go to the call, check the first argument: is this the pointer we expect?
-   Verify that there is no call to that type's constructor between the destruction and the suspected vulnerability.


## Conclusion

In this tutorial, we went from a recording of an exploit to identifying:
- The software being exploited
- Practical details of how the exploit is run
- The type of vulnerability
- The object being corrupted.

We did not however go into why a use-after-free was possible in the VLC code. These can be of multiple sources, in our case it is a logic bug. This is where we would need to turn to a static tool (or look at the code) to analyze further. Still, we have greatly narrowed down the perimeter we would have to look into.